/**
 * DeckRAI ADK Service - HTTP Client
 *
 * This service runs in the browser and acts as the client for the ADK backend server.
 * It replaces the old `intelligentGeneration` and parts of `geminiService` by
 * making HTTP calls to the backend instead of running AI logic directly.
 *
 * This provides a clean separation of concerns and allows the UI to remain
 * unchanged while leveraging the powerful ADK backend.
 */

const API_BASE_URL = import.meta.env.VITE_ADK_API_URL || ''; // Vite proxy will handle this in dev

export interface ADKAnalysisResult {
    questions: Array<{ question: string; options: string[]; reasoning: string; }>;
    suggestions: { recommendedSlideCount: number; recommendedStyle: string; reasoning: string; };
}

export interface ADKSlidesResult {
    slides: Array<{ title: string; content: string; imageUrl?: string; }>;
}

/**
 * A generic function to call the ADK backend.
 * @param userPrompt The main prompt or instruction from the user.
 * @param state Additional context to pass to the ADK session state.
 * @returns The result from the ADK agent.
 */
async function processWithADK(userPrompt: string, state: Record<string, any> = {}): Promise<any> {
    console.log('üåê [ADK Client] Calling backend API at /api/adk/process');
    try {
        const response = await fetch(`${API_BASE_URL}/api/adk/process`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                userPrompt,
                state,
                // sessionId could be managed here for multi-turn conversations
            }),
        });

        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody.error || `HTTP error! Status: ${response.status}`);
        }

        const result = await response.json();
        console.log('‚úÖ [ADK Client] Received response from backend:', result);
        return result.data;

    } catch (error) {
        console.error('‚ùå [ADK Client] Error calling backend:', error);
        // Provide a fallback or re-throw to be handled by the UI
        throw error;
    }
}


/**
 * Drop-in replacement for `intelligentGeneration.analyzeNotesAndAskQuestions`.
 * It calls the ADK backend to get a plan for a new deck.
 */
export async function analyzeNotesAndAskQuestions(
    userPrompt: string,
    mentionedSlideIds?: string[],
    slides?: any[]
): Promise<ADKAnalysisResult> {
    const state: Record<string, any> = {
        mode: (mentionedSlideIds && mentionedSlideIds.length > 0) ? 'edit' : 'create',
        target_slide_ids: mentionedSlideIds,
        existing_slides: slides,
    };

    const adkResult = await processWithADK(userPrompt, state);

    // In a real implementation, this would parse the structured output from the ADK agent.
    // For now, we return a mock structure to ensure UI compatibility.
    return {
        questions: adkResult?.questions || [],
        suggestions: adkResult?.suggestions || {
            recommendedSlideCount: 8,
            recommendedStyle: 'Professional',
            reasoning: 'Plan generated by ADK Coordinator.'
        }
    };
}

/**
 * Drop-in replacement for `intelligentGeneration.generateSlidesWithContext`.
 * It calls the ADK backend to generate the actual slides.
 */
export async function generateSlidesWithContext(context: any): Promise<ADKSlidesResult> {
    const adkResult = await processWithADK("Generate slides based on the provided context.", { generation_context: context });
    
    // Parse the result from the ADK agent into the format the UI expects.
    return {
        slides: adkResult?.slides || []
    };
}

/**
 * Drop-in replacement for `geminiService.executeSlideTask`.
 * It calls the ADK backend to perform a specific edit on a slide.
 */
export async function executeSlideTask(
    slideId: string,
    task: string,
    currentSlideSrc: string,
    slides?: any[]
): Promise<string> {
    const state = {
        mode: 'edit',
        target_slide_ids: [slideId],
        existing_slides: slides,
        edit_request: task,
        current_slide_image: currentSlideSrc,
    };

    const adkResult = await processWithADK(`Perform edit task: "${task}"`, state);

    // Return the new image URL for the edited slide.
    return adkResult?.newImageUrl || currentSlideSrc;
}
