/**
 * DeckRAI ADK Service - HTTP Client
 *
 * This service runs in the browser and acts as the client for the ADK backend server.
 * It replaces the old `intelligentGeneration` and parts of `geminiService` by
 * making HTTP calls to the backend instead of running AI logic directly.
 *
 * This provides a clean separation of concerns and allows the UI to remain
 * unchanged while leveraging the powerful ADK backend.
 */

const API_BASE_URL = import.meta.env.VITE_ADK_API_URL || ''; // Vite proxy will handle this in dev

export interface ADKAnalysisResult {
    questions: Array<{ question: string; options: string[]; reasoning: string; }>;
    suggestions: { recommendedSlideCount: number; recommendedStyle: string; reasoning: string; };
}

export interface ADKSlidesResult {
    slides: Array<{ title: string; content: string; imageUrl?: string; }>;
}

/**
 * Helper to safely get a value from the ADK result's state.
 * The ADK backend returns the final session state.
 */
function getFromADKState(adkResult: any, key: string, defaultValue: any = undefined): any {
    if (adkResult && adkResult.state && adkResult.state[key] !== undefined) {
        return adkResult.state[key];
    }
    return defaultValue;
}

/**
 * A generic function to call the ADK backend.
 * @param userPrompt The main prompt or instruction from the user.
 * @param state Additional context to pass to the ADK session state.
 * @returns The result from the ADK agent.
 */
async function processWithADK(userPrompt: string, state: Record<string, any> = {}): Promise<any> {
    console.log('üåê [ADK Client] Calling backend API at /api/adk/process');
    try {
        const response = await fetch(`${API_BASE_URL}/api/adk/process`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                userPrompt,
                state,
                // sessionId could be managed here for multi-turn conversations
            }),
        });

        if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody.error || `HTTP error! Status: ${response.status}`);
        }

        const result = await response.json();
        console.log('‚úÖ [ADK Client] Received response from backend:', result);
        return result.data; // This 'data' field contains the final session state and agent output

    } catch (error) {
        console.error('‚ùå [ADK Client] Error calling backend:', error);
        // Provide a fallback or re-throw to be handled by the UI
        throw error;
    }
}


/**
 * Drop-in replacement for `intelligentGeneration.analyzeNotesAndAskQuestions`.
 * It calls the ADK backend to get a plan for a new deck.
 */
export async function analyzeNotesAndAskQuestions(
    userPrompt: string,
    mentionedSlideIds?: string[],
    slides?: any[]
): Promise<ADKAnalysisResult> {
    const state: Record<string, any> = {
        mode: (mentionedSlideIds && mentionedSlideIds.length > 0) ? 'edit' : 'create',
        target_slide_ids: mentionedSlideIds,
        existing_slides: slides,
    };

    const adkResult = await processWithADK(userPrompt, state);

    // Extract plan/suggestions from the ADK result
    const plan = getFromADKState(adkResult, 'plan'); // Assuming ADK agent saves plan to state['plan']
    const suggestions = getFromADKState(adkResult, 'suggestions'); // Or directly suggestions

    return {
        questions: getFromADKState(adkResult, 'questions', []), // Assuming ADK agent saves questions
        suggestions: suggestions || plan || { // Fallback to plan if suggestions not direct
            recommendedSlideCount: getFromADKState(adkResult, 'recommendedSlideCount', 8),
            recommendedStyle: getFromADKState(adkResult, 'recommendedStyle', 'Professional'),
            reasoning: getFromADKState(adkResult, 'reasoning', 'Plan generated by ADK Coordinator.')
        }
    };
}

/**
 * Drop-in replacement for `intelligentGeneration.generateSlidesWithContext`.
 * It calls the ADK backend to generate the actual slides.
 */
export async function generateSlidesWithContext(context: any): Promise<ADKSlidesResult> {
    const adkResult = await processWithADK("Generate slides based on the provided context.", { generation_context: context });
    
    // Extract slides from the ADK result
    const slides = getFromADKState(adkResult, 'slides', []); // Assuming ADK agent saves slides to state['slides']

    return {
        slides: slides
    };
}

/**
 * Drop-in replacement for `geminiService.executeSlideTask`.
 * It calls the ADK backend to perform a specific edit on a slide.
 */
export async function executeSlideTask(
    slideId: string,
    task: string,
    currentSlideSrc: string,
    slides?: any[]
): Promise<string> {
    const state = {
        mode: 'edit',
        target_slide_ids: [slideId],
        existing_slides: slides,
        edit_request: task,
        current_slide_image: currentSlideSrc,
    };

    const adkResult = await processWithADK(`Perform edit task: "${task}"`, state);

    // Return the new image URL for the edited slide.
    // Assuming the ADK agent saves the new image URL to state['newImageUrl'] or directly returns it.
    return getFromADKState(adkResult, 'newImageUrl', currentSlideSrc);
}
