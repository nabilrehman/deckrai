/**
 * createSlideTool
 *
 * Creates a NEW slide from scratch based on a detailed prompt
 *
 * Use cases:
 * - Generate individual slides for a deck
 * - Create slides with specific content
 * - Apply brand themes and logos
 * - Include custom images in slides
 *
 * @tool
 */

import { GoogleGenAI } from '@google/genai';
import type { ToolResult, CreateSlideParams, CreateSlideResult, BrandTheme } from '../types';

const ai = new GoogleGenAI({ apiKey: process.env.VITE_GEMINI_API_KEY || '' });

/**
 * Helper: Convert base64 data URL to GenerativePart
 */
function fileToGenerativePart(base64Data: string) {
  const match = base64Data.match(/^data:(image\/\w+);base64,(.*)$/);
  if (!match) {
    throw new Error('Invalid base64 image data string');
  }
  return {
    inlineData: {
      data: match[2],
      mimeType: match[1],
    },
  };
}

/**
 * Helper: Verify image quality with Gemini 3.0 (checks for text spelling errors)
 */
async function verifyImageQuality(
  generatedImage: string,
  originalPrompt: string
): Promise<string | null> {
  const systemPrompt = `You are a meticulous "Quality Assurance Inspector" AI. Your task is to check a newly generated slide image for text accuracy errors.

**Your Goal:** Identify any spelling mistakes, typos, or garbled text.

**Your Process:**
1. **Read all text** visible on the slide image carefully
2. **Check the prompt** to see what the correct spelling should be
3. **Identify text errors** like:
   - Misspellings (e.g., "PoteSGagrul" should be "PostgreSQL")
   - Garbled text (random characters)
   - Missing letters or wrong capitalization

**Your Output:**
- If you find ANY text errors, list them concisely: "The text 'PoteSGagrul' should be 'PostgreSQL'"
- If all text is spelled correctly, respond with only: "OK"`;

  const generatedImagePart = fileToGenerativePart(generatedImage);

  try {
    const response = await ai.models.generateContent({
      model: 'gemini-3-pro-preview',
      contents: [
        { role: 'user', parts: [generatedImagePart] },
        { role: 'user', parts: [{ text: `Original Instructions:\n${originalPrompt}` }] },
        { role: 'user', parts: [{ text: systemPrompt }] },
      ],
    });

    const result = response.text.trim();
    console.log(`[verifyImageQuality] QA Result: ${result}`);

    return result === 'OK' ? null : result;
  } catch (error) {
    console.error('[verifyImageQuality] Error during verification:', error);
    return null; // Don't fail generation if QA fails
  }
}

/**
 * Helper: Generate single image variation using Gemini Flash Image with QA loop
 */
async function generateSingleImage(
  model: string,
  imageParts: any[],
  prompt: string,
  deepMode: boolean,
  enableQA: boolean = true,
  maxRetries: number = 2
): Promise<{ image: string; finalPrompt: string }> {
  let attempt = 0;
  let lastImage: string | null = null;
  let lastPrompt = prompt;

  while (attempt <= maxRetries) {
    attempt++;
    console.log(`[generateSingleImage] Attempt ${attempt}/${maxRetries + 1}`);

    const parts = [...imageParts, { text: lastPrompt }];

    const response = await ai.models.generateContent({
      model,
      contents: [{ role: 'user', parts }],
      config: {
        thinking: deepMode
          ? { mode: 'deep', instruction: 'Think deeply about visual design principles, layout, and aesthetics' }
          : undefined,
      },
    });

    // Find the image part
    const responseParts = response?.candidates?.[0]?.content?.parts || [];
    let base64ImageBytes: string | undefined;
    let mimeType = 'image/png';

    for (const part of responseParts) {
      if (part.inlineData?.data) {
        base64ImageBytes = part.inlineData.data;
        mimeType = part.inlineData.mimeType || 'image/png';
        break;
      }
    }

    if (!base64ImageBytes) {
      console.error('[generateSingleImage] No image found in response parts');
      throw new Error('No image was generated by Gemini (Reason: NO_IMAGE)');
    }

    lastImage = `data:${mimeType};base64,${base64ImageBytes}`;

    // QA Check with Gemini 3.0 (skip on last attempt to avoid infinite loop)
    if (enableQA && attempt <= maxRetries) {
      console.log(`[generateSingleImage] Running QA review with Gemini 3.0...`);
      const correction = await verifyImageQuality(lastImage, prompt);

      if (correction) {
        console.log(`[generateSingleImage] ‚ö†Ô∏è QA found issues: ${correction}`);
        console.log(`[generateSingleImage] üîÑ Retrying with corrections...`);
        lastPrompt = `${prompt}\n\n**CRITICAL CORRECTION FROM QA:** You made spelling errors. Please regenerate and fix: ${correction}`;
        continue; // Retry
      } else {
        console.log(`[generateSingleImage] ‚úÖ QA passed - text is accurate`);
        break; // Success!
      }
    } else {
      break; // Max retries reached or QA disabled
    }
  }

  return {
    image: lastImage!,
    finalPrompt: lastPrompt,
  };
}

/**
 * Creates a new slide from a detailed prompt
 * Wraps the tested createSlideFromPrompt logic from services/geminiService.ts
 */
export async function createSlide(params: CreateSlideParams): Promise<ToolResult<CreateSlideResult>> {
  const startTime = Date.now();

  try {
    console.log(`[createSlideTool] Creating slide with prompt length: ${params.detailedPrompt.length}`);
    console.log(`[createSlideTool] Theme: ${params.theme ? 'YES' : 'NO'}`);
    console.log(`[createSlideTool] Images: ${params.images?.length || 0}`);
    console.log(`[createSlideTool] Deep Mode: ${params.deepMode}`);

    // Build theme instructions
    let themeInstructions = '';
    if (params.theme) {
      themeInstructions = `

**THEME INSTRUCTIONS:**
- Primary Color: ${params.theme.primaryColor}
- Secondary Color: ${params.theme.secondaryColor}
- Accent Color: ${params.theme.accentColor}
- Font Style: ${params.theme.fontStyle}
- Visual Style: ${params.theme.visualStyle}`;
    }

    // Build image parts array and instructions
    const imageParts: any[] = [];
    let imageInstructions = '';

    if (params.images && params.images.length > 0) {
      // Group images by purpose
      const referenceImages = params.images.filter(img => img.purpose === 'reference');
      const logoImages = params.images.filter(img => img.purpose === 'logo');
      const customImages = params.images.filter(img => img.purpose === 'custom');

      // Add reference slides
      if (referenceImages.length > 0) {
        imageInstructions += `\n\n**REFERENCE SLIDES FOR STYLE:**\n`;
        referenceImages.forEach((img, idx) => {
          imageParts.push({ text: `--- REFERENCE SLIDE ${idx + 1}: ${img.label} ---` });
          imageParts.push(fileToGenerativePart(img.image));
          imageInstructions += `- Reference ${idx + 1}: ${img.label}\n`;
        });
        imageInstructions += `\nMATCH the visual style, aesthetics, color palette, font choices, and layout principles from these reference slides.`;
      }

      // Add logos
      if (logoImages.length > 0) {
        imageInstructions += `\n\n**LOGO PLACEMENT INSTRUCTIONS:**\n`;
        logoImages.forEach((img, idx) => {
          imageParts.push({ text: `--- LOGO ${idx + 1}: ${img.label} ---` });
          imageParts.push(fileToGenerativePart(img.image));
          imageInstructions += `- Logo ${idx + 1}: ${img.label}\n`;
        });
        imageInstructions += `
**CRITICAL: PRESERVE EXISTING LOGOS**
- If the original slide already contains logos, keep them exactly as they are
- Add new logos without replacing existing ones
- Position: Top-right corner preferred (if available), otherwise top-left or bottom corners
- Size: Approximately 120-180px width (scale proportionally)
- Padding: 40-60px from edges
- Style: Recreate the logo's colors, shapes, and design elements faithfully
- Quality: Make logos clear, sharp, and professional
- If multiple logos exist, arrange them in a clean, balanced way`;
      }

      // Add custom images
      if (customImages.length > 0) {
        imageInstructions += `\n\n**CUSTOM IMAGES TO INCORPORATE:**\n`;
        customImages.forEach((img, idx) => {
          imageParts.push({ text: `--- CUSTOM IMAGE ${idx + 1}: ${img.label} ---` });
          imageParts.push(fileToGenerativePart(img.image));
          imageInstructions += `- Image ${idx + 1}: ${img.label}\n`;
        });
        imageInstructions += `\nIncorporate these images into the slide design in a visually appealing and professional manner that complements the overall layout.`;
      }
    }

    // Build designer system prompt
    const hasReferenceImages = params.images?.some(img => img.purpose === 'reference');
    const designerSystemPrompt = hasReferenceImages
      ? `You are a "Creative Slide Designer" AI. Your task is to create a brand new slide from scratch based on a detailed prompt.

**CRITICAL RULES:**
1.  **Reference Style:** You are provided with reference slide images. The new slide you create MUST perfectly match the visual style, aesthetics, color palette, font choices, and general layout principles of these reference slides.
2.  **Follow Prompt:** Create the content of the new slide based *only* on the detailed prompt.
3.  **Aspect Ratio:** The new slide you create MUST be in a 16:9 aspect ratio.
4.  **Text Accuracy:** Copy all technical terms, product names, and proper nouns EXACTLY as written in the prompt. Double-check spelling.
---
**Detailed Prompt:** "${params.detailedPrompt}"${themeInstructions}${imageInstructions}`
      : `You are a "Creative Slide Designer" AI. Your task is to create a brand new slide from scratch based on a detailed prompt.

**CRITICAL RULES:**
1. **Design Style:** Since no reference image is provided, create a clean, professional, and visually appealing design. Use a modern, minimalist aesthetic with good typography and layout principles.
2.  **Follow Prompt:** Create the content of the new slide based *only* on the detailed prompt.
3.  **Aspect Ratio:** The new slide you create MUST be in a 16:9 aspect ratio.
4.  **Text Accuracy:** Copy all technical terms, product names, and proper nouns EXACTLY as written in the prompt. Double-check spelling.
---
**Detailed Prompt:** "${params.detailedPrompt}"${themeInstructions}${imageInstructions}`;

    // Generate the slide
    console.log(`[createSlideTool] Generating slide with Gemini 2.5 Flash Image...`);
    const result = await generateSingleImage(
      'gemini-3-pro-image-preview',
      imageParts,
      designerSystemPrompt,
      params.deepMode,
      false  // Disable QA review to save tokens and time
    );

    const executionTime = Date.now() - startTime;
    console.log(`[createSlideTool] ‚úÖ Slide created in ${executionTime}ms`);

    return {
      success: true,
      data: {
        images: [result.image],
        prompts: [result.finalPrompt],
      },
      metadata: {
        executionTime,
        model: 'gemini-3-pro-image-preview',
      },
    };
  } catch (error: any) {
    const executionTime = Date.now() - startTime;
    console.error(`[createSlideTool] ‚ùå Error:`, error);

    return {
      success: false,
      error: {
        code: 'SLIDE_CREATION_FAILED',
        message: 'Failed to create slide',
        details: error.message,
      },
      metadata: {
        executionTime,
      },
    };
  }
}

/**
 * ADK Tool Schema (to be exported by tools/index.ts)
 */
export const createSlideTool = {
  name: 'createSlideTool',
  description: 'Create a NEW slide from scratch based on a detailed prompt. Supports multiple reference slides, logos, and custom images. Gemini 2.5 Flash can process any number of images simultaneously.',
  parameters: {
    type: 'object',
    properties: {
      detailedPrompt: {
        type: 'string',
        description: 'Detailed description of the slide content and layout',
      },
      deepMode: {
        type: 'boolean',
        description: 'Enable deep thinking mode for better visual design (slower but higher quality)',
      },
      theme: {
        type: 'object',
        description: 'Optional: Brand theme with colors and typography',
        properties: {
          primaryColor: { type: 'string' },
          secondaryColor: { type: 'string' },
          accentColor: { type: 'string' },
          fontStyle: { type: 'string' },
          visualStyle: { type: 'string' },
          sources: { type: 'array', items: { type: 'string' } },
        },
      },
      images: {
        type: 'array',
        description: 'Optional: Array of images to include. Can pass any number of images (reference slides, logos, custom images). Each image has: {image: base64DataURL, label: description, purpose: "reference"|"logo"|"custom"}',
        items: {
          type: 'object',
          properties: {
            image: {
              type: 'string',
              description: 'Base64 data URL of the image',
            },
            label: {
              type: 'string',
              description: 'Description/label for this image (e.g., "Company logo", "Product screenshot", "Style reference")',
            },
            purpose: {
              type: 'string',
              enum: ['reference', 'logo', 'custom'],
              description: 'Purpose of this image: "reference" for style matching, "logo" for logos to add, "custom" for content images',
            },
          },
          required: ['image', 'label', 'purpose'],
        },
      },
    },
    required: ['detailedPrompt', 'deepMode'],
  },
  execute: createSlide,
};
