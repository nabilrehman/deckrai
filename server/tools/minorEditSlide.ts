/**
 * minorEditSlideTool
 *
 * Makes MINOR edits to an existing slide using inpainting/masking
 *
 * Use cases:
 * - Change text in a specific region
 * - Modify colors or styling in a specific area
 * - Replace specific visual elements
 * - Fix typos or update data
 *
 * @tool
 */

import { GoogleGenAI } from '@google/genai';
import type { ToolResult, MinorEditSlideParams, MinorEditSlideResult } from '../types';

const ai = new GoogleGenAI({ apiKey: process.env.VITE_GEMINI_API_KEY || '' });

/**
 * Helper: Convert base64 data URL to GenerativePart
 */
function fileToGenerativePart(base64Data: string) {
  const match = base64Data.match(/^data:(image\/\w+);base64,(.*)$/);
  if (!match) {
    throw new Error('Invalid base64 image data string');
  }
  return {
    inlineData: {
      data: match[2],
      mimeType: match[1],
    },
  };
}

/**
 * Helper: Generate inpainted/edited image using Gemini Flash Image
 * Now accepts an array of image parts (can include multiple images)
 */
async function generateEditedImage(
  imageParts: any[],
  prompt: string,
  deepMode: boolean
): Promise<{ image: string; finalPrompt: string }> {
  const parts = [...imageParts, { text: prompt }];

  const response = await ai.models.generateContent({
    model: 'gemini-2.5-flash-image',
    contents: [{ role: 'user', parts }],
    config: {
      thinking: deepMode
        ? { mode: 'deep', instruction: 'Think carefully about how to seamlessly integrate the edit into the existing slide design' }
        : undefined,
    },
  });

  // Find the image part (could be in any position in parts array)
  const responseParts = response?.candidates?.[0]?.content?.parts || [];
  let base64ImageBytes: string | undefined;
  let mimeType = 'image/png';

  for (const part of responseParts) {
    if (part.inlineData?.data) {
      base64ImageBytes = part.inlineData.data;
      mimeType = part.inlineData.mimeType || 'image/png';
      break;
    }
  }

  if (!base64ImageBytes) {
    throw new Error('No image was generated by Gemini (Reason: NO_IMAGE)');
  }
  return {
    image: `data:${mimeType};base64,${base64ImageBytes}`,
    finalPrompt: prompt,
  };
}

/**
 * Makes minor edits to an existing slide
 * Supports two modes:
 * 1. With mask: Inpainting (only edit masked region)
 * 2. Without mask: Instruction-based editing (e.g., "add logo to top right")
 *
 * Wraps the tested getInpaintingVariations logic from services/geminiService.ts
 */
export async function minorEditSlide(params: MinorEditSlideParams): Promise<ToolResult<MinorEditSlideResult>> {
  const startTime = Date.now();

  try {
    console.log(`[minorEditSlideTool] Editing slide with instruction: ${params.prompt.substring(0, 100)}...`);
    console.log(`[minorEditSlideTool] Mode: ${params.base64Mask ? 'Inpainting (with mask)' : 'Instruction-based (no mask)'}`);
    console.log(`[minorEditSlideTool] Additional Images: ${params.additionalImages?.length || 0}`);
    console.log(`[minorEditSlideTool] Deep Mode: ${params.deepMode}`);

    // Build image parts array
    const imageParts: any[] = [];

    // Add original slide
    imageParts.push({ text: '--- ORIGINAL SLIDE (TO EDIT) ---' });
    imageParts.push(fileToGenerativePart(params.base64Image));

    // Add mask if provided
    if (params.base64Mask) {
      imageParts.push({ text: '--- MASK (WHITE = EDIT, BLACK = PRESERVE) ---' });
      imageParts.push(fileToGenerativePart(params.base64Mask));
    }

    // Add additional images (e.g., logos to add, style references)
    if (params.additionalImages && params.additionalImages.length > 0) {
      params.additionalImages.forEach((img, idx) => {
        imageParts.push({ text: `--- ADDITIONAL IMAGE ${idx + 1}: ${img.label} ---` });
        imageParts.push(fileToGenerativePart(img.image));
      });
    }

    // Build prompt based on mode
    let prompt: string;

    if (params.base64Mask) {
      // MODE 1: Inpainting with mask (only edit masked region)
      prompt = `**Task: Inpainting**
Perform the following instruction ONLY within the masked area of the image. DO NOT change any pixels outside the masked area.

**Instruction:** "${params.prompt}"`;

      console.log(`[minorEditSlideTool] Generating inpainted image (masked region only)...`);
    } else {
      // MODE 2: Instruction-based editing (no mask)
      let additionalContext = '';
      if (params.additionalImages && params.additionalImages.length > 0) {
        additionalContext = '\n\n**Additional Reference Images:**\n';
        params.additionalImages.forEach((img, idx) => {
          additionalContext += `- Image ${idx + 1}: ${img.label}\n`;
        });
        additionalContext += '\nUse these reference images as needed to complete the edit instruction.';
      }

      prompt = `**Task: Minor Slide Edit**
Make the following MINOR edit to this slide. Keep the overall design, layout, and style the same. Only make the specific change requested.

**Edit Instruction:** "${params.prompt}"${additionalContext}

**Important:** This is a MINOR edit, not a complete redesign. Preserve the existing slide's structure, colors, fonts, and layout as much as possible.`;

      console.log(`[minorEditSlideTool] Generating edited slide (instruction-based)...`);
    }

    const result = await generateEditedImage(
      imageParts,
      prompt,
      params.deepMode
    );

    const executionTime = Date.now() - startTime;
    console.log(`[minorEditSlideTool] ✅ Inpainting complete in ${executionTime}ms`);

    return {
      success: true,
      data: {
        images: [result.image],
        variationPrompts: [result.finalPrompt],
      },
      metadata: {
        executionTime,
        model: 'gemini-2.5-flash-image',
      },
    };
  } catch (error: any) {
    const executionTime = Date.now() - startTime;
    console.error(`[minorEditSlideTool] ❌ Error:`, error);

    return {
      success: false,
      error: {
        code: 'INPAINTING_FAILED',
        message: 'Failed to perform inpainting on slide',
        details: error.message,
      },
      metadata: {
        executionTime,
      },
    };
  }
}

/**
 * ADK Tool Schema (to be exported by tools/index.ts)
 */
export const minorEditSlideTool = {
  name: 'minorEditSlideTool',
  description: `Make MINOR edits to an existing slide. Supports TWO modes and multiple additional images:

1. **Inpainting Mode (with mask)**: Edit only a specific region by providing a mask image. The mask highlights the area to modify (white = edit, black = preserve). Perfect for precise regional changes.

2. **Instruction Mode (without mask)**: Make small changes based on text instructions (e.g., "add logo to top right", "change date to November 2025"). The tool preserves the overall design while making the requested change.

**Multi-image support**: Can include additional images (logos, icons, reference images) that Gemini 2.5 Flash will use to complete the edit.

Use cases:
- Add elements (logo, icon, text) to specific locations
- Change existing text or data
- Fix typos or update information
- Modify colors or styling in specific areas
- Replace individual visual elements
- Add specific logos or images to the slide

NOT for: Complete redesigns, major layout changes, or generating multiple variations (use redesignSlideTool instead).`,
  parameters: {
    type: 'object',
    properties: {
      prompt: {
        type: 'string',
        description: 'Edit instruction. Examples: "Add the provided logo to top right corner", "Change Month 20XX to November 2025", "Add the product image to the center", "Replace the icon with the provided one"',
      },
      base64Image: {
        type: 'string',
        description: 'Base64 data URL of the original slide image to edit',
      },
      base64Mask: {
        type: 'string',
        description: 'OPTIONAL: Base64 data URL of the mask image (white = edit region, black = preserve region). If provided, only masked area is edited (inpainting mode). If not provided, entire slide can be edited based on instruction (instruction mode).',
      },
      additionalImages: {
        type: 'array',
        description: 'OPTIONAL: Array of additional images to use in the edit (e.g., logos to add, icons to use, reference images). Can pass any number of images.',
        items: {
          type: 'object',
          properties: {
            image: {
              type: 'string',
              description: 'Base64 data URL of the image',
            },
            label: {
              type: 'string',
              description: 'Description/label for this image (e.g., "Company logo", "Product icon", "Reference image")',
            },
          },
          required: ['image', 'label'],
        },
      },
      deepMode: {
        type: 'boolean',
        description: 'Enable deep thinking mode for better quality edits (slower but more precise)',
      },
    },
    required: ['prompt', 'base64Image', 'deepMode'],
  },
  execute: minorEditSlide,
};
